《Java核心（五）深入理解BIO、NIO、AIO（原）》
   https://my.oschina.net/u/3471412/blog/2966696

《Java基础—线程》
   https://www.cnblogs.com/jiangbei/p/6664555.html

《Java多线程》标签
   https://www.cnblogs.com/linjiqin/tag/java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/

《Java多线程并发》
   https://www.cnblogs.com/zch-lxh1314/p/7090653.html

《在多核或多处理器时代，为什么要特别 重视 Java 多线程 开发模式》
   https://blog.csdn.net/zolalad/article/details/25336369

《java高并发设计》系列
   https://my.oschina.net/wangshuaixin?tab=newest&catalogId=340595

《cpu个数、核数、线程数、Java多线程关系综合》
   https://blog.csdn.net/ohbxiaoxin/article/details/82217498

《Java集合及concurrent并发包总结（转）》
   https://www.cnblogs.com/cccw/p/5837448.html   


======================================================================

Java编程思想之并发

并发编程要明确的问题：
  - 使用并发时需要解决的问题有多个
  - 实现并发的方式有多种


总体思路：如果你想让一个程序运行得更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。
理论依据：并发是用于多处理器编程的基本工具。当前速度的提高是以多核处理器的形式而不是更快的芯片的形式出现的。为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。

使用并发时需要解决的问题：

1.Java的线程机制是抢占式的，而如果想利用Java的线程机制来实现协作式的系统，那么要求程序员有意识的在每个任务中插入让步语句。
  Java抢占式线程机制的形成原因：调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片段，使得每个线程都分配到数量合理的时间去驱动它的任务。
  协作式系统的特点：每个任务都会自动放弃控制，这要求程序员在协作式系统中利用Java线程的时候有意识地在每个任务中插入让步语句。
  -- 协作式系统的优点：上下文切换的开销比抢占式要低廉的多，可以同时执行的线程数量理论上没有限制。当你处理大量的仿真元素时，这是一种理想的解决方案。
  -- 协作式系统的局限：某些协作式系统并未设计为可以在多个处理器之间分配任务，这可能会非常有限。

  使用Java线程的并发方式来实现协作式系统的性价比：并发虽然需要付出代价，但这些代价与在程序设计、资源负载均衡以及用户方便方面的改进相比，就显得微不足道。通常，线程能够使我们创建更加松耦合的设计。


========================= 并发编程的具体实现原理 =====================
并发编程使得我们可以将程序划分为多个分离的、独立的任务。通过使用多线程机制，这些独立任务中的每一个都将有执行程序来驱动。单个进程可以拥有多个并发执行的任务，但是每个任务都好像有其自己的CPU一样。线程模型简化了在单一程序中同时多个操作的处理。
多线程模型的底层机制是切分CPU时间。在使用线程时，CPU将轮流给每个任务分配其可占用的时间，这样，每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分片段分配给了所有任务（同时也有可能有些任务被划分运行在了多个CPU之上）。而这个划分的依据是由线程模型来完成的，你的代码不需要知道线程是运行在一个还是多个CPU上。
所以，使用线程机制是一个建立透明的、可扩展的程序的方法，因为如果程序运行速度太慢，为机器增添一个CPU就很容易的增加程序运行的速度。多个任务、多个线程是使用多个处理器系统的最合理方式。


======================= 定义线程的方式 ============================
1.普通需要在线程中执行的任务可以通过实现Runnable并把要执行的处理逻辑定义在run()方法中。
2.要把Runnable任务转变为一个线程工作任务，需要把它提交给一个Thread构造器。

  Thread的运行原理：
      Thread构造器只需要一个Runnable对象。调用thread.start()方法为该线程的执行提供必须的初始化操作，然后调用runnable的run()方法，以便在这个线程中启动任务。
      thread.start()语句实际上只是产生了对runnable.run()方法的调用，并不会继续等待。

      当创建Thread对象时，还没有创建对Thread对象的引用。但是当调用thread.start()使用它时，对于垃圾回收器来说，每个Thread都注册了自己、存在一个对它自己的引用，而且在任务退出run()死亡之前，垃圾回收器是无法清除它的。

===================== 使用Executor提交执行线程 =========================
Java SE5的java.util.concurrent包中的执行器（Executor）将为你管理Thread对象，简化了并发编程。有了Executor，使用者不必自己再为每个线程创建Thread对象，只需要将runnable任务提交给Executor去执行。

Executor的shutdown()方法的调用可以防止新任务被提交给这个Executor，当前线程将继续运行在shutdown()被提交之前提交的所有任务。

Executor包含了不同的类型：
 -- FixedThreadPool
    这种Executor使用了有限的线程集来执行提交的任务，这样，你可以一次性预先执行代价高昂的线程分配，同时也可以达到限制线程数量的目的。而且你也不必为每个线程都固定地去创建它自己独有的线程。因为，在任何线程池中，现有线程在可能的情况下都会复用。

 -- CachedThreadPool
    创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

 -- SingleThreadExecutor
    创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO / LIFO / 优先级）执行。

 -- ScheduledThreadPool
    创建一个定长线程池，支持定时及周期性任务执行。

 使用线程池最直接的好处就是：线程可以重复利用、减少创建和销毁线程所带来的系统资源的开销，提升性能（节省线程创建的时间开销，使程序响应更快）。


=========================================================================

CachedThreadPool
-- 核心线程数被设置为0，这样保证任何时刻都满足线程数大于核心线程数的条件；
-- 空闲线程等待新任务的最长时间是60s，超过此时长还没有新任务提交此空闲线程将会被销毁；
-- 当向线程池提交任务的速度 > 线程池中线程处理任务的速度时就要不断创建新线程；
-- maximumPoolSize被设置为Integer.MAX_VALUE，基本上可以理解为线程池的大小是没有限制的，每次提交任务，都会立即有线程去处理；
-- 适用于处理大量、耗时少的任务，否则创建大量的线程可能导致严重的性能问题。

[补充]
   CachedThreadPool工作的基本规则是：如果线程池中的线程数大于核心线程数，且队列满了，且线程数小于最大线程数，则会创建新的线程。


FixedThreadPool
-- 如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来响应执行后续的任务。所有的线程都会一直存在于线程池中，直到显式地执行ExecutorService.shutdown()关闭。
-- 这种线程池可创建的线程数可以考虑设计为CPU核数*N（N可大可小，取决于并发的线程数，计算机可用的硬件资源等）。可以通过Runtime.getRuntime().availableProcessors()来获取当前计算机的CPU的核数。
-- 这种线程池不会拒绝任务，而且不会开辟新的线程，也不会因为线程的长时间不使用而销毁线程。适合用在稳定且固定的并发场景，比如服务器。


SingleThreadExecutor
-- 当线程运行时抛出异常的时候会有新的线程加入线程池替它完成接下来的任务。
-- 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（）执行，所以这个比较适合那些需要按序（FIFO / LIFO / 优先级）执行任务的场景。比如：一些不太重要的收尾、日志等工作可以放到单线程的线程池中去执行。日志记录一般情况会比较慢（数据量大一般可能不写入数据库），顺序执行会拖慢整个接口，堆积更多请求，还可能会对数据库造成影响（事务在开启中），所以日志记录完全可以扔到单线程的线程池中去，一条条的处理，也可以认为是一个单消费者的生产者消费者模式。


ScheduledThreadPool
-- 相比于FixedThreadPool, 此线程池强大在于：1、可以执行延时任务; 2、也可以执行带有返回值的任务
   