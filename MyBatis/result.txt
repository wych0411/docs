在MyBatis中使用association和collection实现一对一和一对多关系时需要对关系中结果进行筛选，如果联合使用select标签时，主sql和关系映射里的sql是分开的，查询参数传递会成为问题。

【解决方案】
  association和collection的column属性用于指定数据库的列名或者列标签别名。与传递给resultSet.getString(columnName)的参数名称相同。注意：在处理组合键时，可以使用column="{prop1=col1,prop2=col2}"这样的语法，设置多个列名传入到嵌套查询语句。这就会把prop1和prop2设置到目标嵌套选择语句的参数对象中。

----------------------------------------------------------------
MyBatis one-to-many mapping

We can map one-to-many types of results to a collection of objects using the <collection> element.

We can map one-to-many relationships using a nested ResultMap and nested Select approaches.

使用嵌套的ResultMap, SELECT语句使用JOIN语法：
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>
<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <collection property="courses" resultMap="CourseResult"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID, C.NAME, DESCRIPTION, START_DATE, END_DATE
    FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID = A.ADDR_ID LEFT OUTER JOIN COURSES C ON T.TUTOR_ID = C.TUTOR_ID
    WHERE T.TUTOR_ID = #{tutorId}
</select>
<!-- 注意嵌套ResultMap中字段的顺序与SELECT语句中字段顺序的对应 -->  


使用嵌套的ResultMap和嵌套的SELECT：
<resultMap type="Course" id="CourseResult">
    <id column="course_id" property="courseId"/>
    <result column="name" property="name"/>
    <result column="description" property="description"/>
    <result column="start_date" property="startDate"/>
    <result column="end_date" property="endDate"/>
</resultMap>
<resultMap type="Tutor" id="TutorResult">
    <id column="tutor_id" property="tutorId"/>
    <result column="tutor_name" property="name"/>
    <result column="email" property="email"/>
    <association property="address" resultMap="AddressResult"/>
    <collection property="courses" column="tutor_id" select="findCoursesByTutor"/>
</resultMap>

<select id="findTutorById" parameterType="int" resultMap="TutorResult">
    SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL FROM TUTORS T WHERE T.TUTOR_ID=#{tutorId}
</select>
<select id="findCoursesByTutor" parameterType="int" resultMap="CourseResult">
    SELECT * FROM COURSES WHERE TUTOR_ID=#{tutorId}
</select>

A nested select approach may result in N+1 select problems. First, the main query will be executed (1), and for every row returned by the first query, another select query will be executed (N queries for N rows). For large datasets, this could result in poor performance.
使用嵌套查询的弊端是会执行N+1次查询（1次主查询+N次子查询），这种方式对于大数据量的查询场景来说是低效的。